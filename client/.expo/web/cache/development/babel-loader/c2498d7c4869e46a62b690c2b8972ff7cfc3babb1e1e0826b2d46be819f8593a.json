{"ast":null,"code":"import { always, block, call, clockRunning, cond, set, startClock, stopClock } from \"../base\";\nimport Clock from \"../core/AnimatedClock\";\nimport { evaluateOnce } from \"../derived/evaluateOnce\";\nfunction createOldAnimationObject(node, animationStateDefaults, value, config) {\n  var newClock = new Clock();\n  var currentState = animationStateDefaults();\n  var alwaysNode;\n  var isStarted = false;\n  var isDone = false;\n  var wasStopped = false;\n  var animationCallback;\n  var animation = {\n    start: function start(currentAnimationCallback) {\n      animationCallback = currentAnimationCallback;\n      if (isStarted) {\n        animationCallback && animationCallback({\n          finished: false\n        });\n        return;\n      }\n      if (isDone) {\n        console.warn('Animation has been finished before');\n        return;\n      }\n      if (!value.isNativelyInitialized()) {\n        return;\n      }\n      isStarted = true;\n      evaluateOnce(set(currentState.position, value), currentState.position, function () {\n        alwaysNode = always(set(value, block([cond(clockRunning(newClock), 0, startClock(newClock)), node(newClock, currentState, config), cond(currentState.finished, [call([], function () {\n          isStarted = false;\n          if (!wasStopped) {\n            isDone = true;\n          }\n          value.__detachAnimation(animation);\n          isDone = true;\n          if (!wasStopped) {\n            wasStopped = false;\n          }\n        }), stopClock(newClock)]), currentState.position])));\n        value.__attachAnimation(animation);\n        alwaysNode.__addChild(value);\n      });\n    },\n    __detach: function __detach() {\n      animationCallback && animationCallback({\n        finished: isDone\n      });\n      animationCallback = null;\n      value.__initialized && alwaysNode.__removeChild(value);\n    },\n    stop: function stop() {\n      if (isDone) {\n        console.warn('Calling stop has no effect as the animation has already completed');\n        return;\n      }\n      if (!isStarted) {\n        console.warn(\"Calling stop has no effect as the animation hasn't been started\");\n        return;\n      }\n      wasStopped = true;\n      evaluateOnce(set(currentState.finished, 1), currentState.finished);\n    },\n    __stopImmediately_testOnly: function __stopImmediately_testOnly(result) {\n      animation.stop();\n      isDone = result;\n      value.__detachAnimation(animation);\n    }\n  };\n  return animation;\n}\nexport default function backwardsCompatibleAnimWrapper(node, animationStateDefaults) {\n  return function (clock, state, config) {\n    if (config !== undefined) {\n      return node(clock, state, config);\n    }\n    return createOldAnimationObject(node, animationStateDefaults, clock, state);\n  };\n}","map":{"version":3,"names":["always","block","call","clockRunning","cond","set","startClock","stopClock","Clock","evaluateOnce","createOldAnimationObject","node","animationStateDefaults","value","config","newClock","currentState","alwaysNode","isStarted","isDone","wasStopped","animationCallback","animation","start","currentAnimationCallback","finished","console","warn","isNativelyInitialized","position","__detachAnimation","__attachAnimation","__addChild","__detach","__initialized","__removeChild","stop","__stopImmediately_testOnly","result","backwardsCompatibleAnimWrapper","clock","state","undefined"],"sources":["C:/Users/Admin/Code/git clone/EThrift/client/node_modules/react-native-reanimated/lib/reanimated1/animations/backwardCompatibleAnimWrapper.js"],"sourcesContent":["import {\r\n  always,\r\n  block,\r\n  call,\r\n  clockRunning,\r\n  cond,\r\n  set,\r\n  startClock,\r\n  stopClock,\r\n} from '../base';\r\nimport Clock from '../core/AnimatedClock';\r\nimport { evaluateOnce } from '../derived/evaluateOnce';\r\n\r\nfunction createOldAnimationObject(node, animationStateDefaults, value, config) {\r\n  const newClock = new Clock();\r\n  const currentState = animationStateDefaults();\r\n  let alwaysNode;\r\n  let isStarted = false;\r\n  let isDone = false;\r\n  let wasStopped = false;\r\n  let animationCallback;\r\n  const animation = {\r\n    start: (currentAnimationCallback) => {\r\n      animationCallback = currentAnimationCallback;\r\n      if (isStarted) {\r\n        animationCallback && animationCallback({ finished: false });\r\n        return;\r\n      }\r\n      if (isDone) {\r\n        console.warn('Animation has been finished before');\r\n        // inconsistent with React Native\r\n        return;\r\n      }\r\n\r\n      if (!value.isNativelyInitialized()) {\r\n        return;\r\n      }\r\n\r\n      isStarted = true;\r\n      evaluateOnce(\r\n        set(currentState.position, value),\r\n        currentState.position,\r\n        () => {\r\n          alwaysNode = always(\r\n            set(\r\n              value,\r\n              block([\r\n                cond(clockRunning(newClock), 0, startClock(newClock)),\r\n                node(newClock, currentState, config),\r\n                cond(currentState.finished, [\r\n                  call([], () => {\r\n                    isStarted = false;\r\n                    if (!wasStopped) {\r\n                      isDone = true;\r\n                    }\r\n                    value.__detachAnimation(animation);\r\n                    isDone = true;\r\n                    if (!wasStopped) {\r\n                      wasStopped = false;\r\n                    }\r\n                  }),\r\n                  stopClock(newClock),\r\n                ]),\r\n                currentState.position,\r\n              ])\r\n            )\r\n          );\r\n          value.__attachAnimation(animation);\r\n          alwaysNode.__addChild(value);\r\n        }\r\n      );\r\n    },\r\n    __detach: () => {\r\n      animationCallback && animationCallback({ finished: isDone });\r\n      animationCallback = null;\r\n      value.__initialized && alwaysNode.__removeChild(value);\r\n    },\r\n    stop: () => {\r\n      if (isDone) {\r\n        console.warn(\r\n          'Calling stop has no effect as the animation has already completed'\r\n        );\r\n        return;\r\n      }\r\n      if (!isStarted) {\r\n        console.warn(\r\n          \"Calling stop has no effect as the animation hasn't been started\"\r\n        );\r\n        return;\r\n      }\r\n      wasStopped = true;\r\n      evaluateOnce(set(currentState.finished, 1), currentState.finished);\r\n    },\r\n    __stopImmediately_testOnly: (result) => {\r\n      animation.stop();\r\n      isDone = result;\r\n      value.__detachAnimation(animation);\r\n    },\r\n  };\r\n  return animation;\r\n}\r\n\r\n/**\r\n * Depending on the arguments list we either return animation node or return an\r\n * animation object that is compatible with the original Animated API\r\n */\r\nexport default function backwardsCompatibleAnimWrapper(\r\n  node,\r\n  animationStateDefaults\r\n) {\r\n  return (clock, state, config) => {\r\n    if (config !== undefined) {\r\n      return node(clock, state, config);\r\n    }\r\n    return createOldAnimationObject(node, animationStateDefaults, clock, state);\r\n  };\r\n}\r\n"],"mappings":"AAAA,SACEA,MAAM,EACNC,KAAK,EACLC,IAAI,EACJC,YAAY,EACZC,IAAI,EACJC,GAAG,EACHC,UAAU,EACVC,SAAS;AAEX,OAAOC,KAAK;AACZ,SAASC,YAAY;AAErB,SAASC,wBAAwBA,CAACC,IAAI,EAAEC,sBAAsB,EAAEC,KAAK,EAAEC,MAAM,EAAE;EAC7E,IAAMC,QAAQ,GAAG,IAAIP,KAAK,CAAC,CAAC;EAC5B,IAAMQ,YAAY,GAAGJ,sBAAsB,CAAC,CAAC;EAC7C,IAAIK,UAAU;EACd,IAAIC,SAAS,GAAG,KAAK;EACrB,IAAIC,MAAM,GAAG,KAAK;EAClB,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIC,iBAAiB;EACrB,IAAMC,SAAS,GAAG;IAChBC,KAAK,EAAE,SAAAA,MAACC,wBAAwB,EAAK;MACnCH,iBAAiB,GAAGG,wBAAwB;MAC5C,IAAIN,SAAS,EAAE;QACbG,iBAAiB,IAAIA,iBAAiB,CAAC;UAAEI,QAAQ,EAAE;QAAM,CAAC,CAAC;QAC3D;MACF;MACA,IAAIN,MAAM,EAAE;QACVO,OAAO,CAACC,IAAI,CAAC,oCAAoC,CAAC;QAElD;MACF;MAEA,IAAI,CAACd,KAAK,CAACe,qBAAqB,CAAC,CAAC,EAAE;QAClC;MACF;MAEAV,SAAS,GAAG,IAAI;MAChBT,YAAY,CACVJ,GAAG,CAACW,YAAY,CAACa,QAAQ,EAAEhB,KAAK,CAAC,EACjCG,YAAY,CAACa,QAAQ,EACrB,YAAM;QACJZ,UAAU,GAAGjB,MAAM,CACjBK,GAAG,CACDQ,KAAK,EACLZ,KAAK,CAAC,CACJG,IAAI,CAACD,YAAY,CAACY,QAAQ,CAAC,EAAE,CAAC,EAAET,UAAU,CAACS,QAAQ,CAAC,CAAC,EACrDJ,IAAI,CAACI,QAAQ,EAAEC,YAAY,EAAEF,MAAM,CAAC,EACpCV,IAAI,CAACY,YAAY,CAACS,QAAQ,EAAE,CAC1BvB,IAAI,CAAC,EAAE,EAAE,YAAM;UACbgB,SAAS,GAAG,KAAK;UACjB,IAAI,CAACE,UAAU,EAAE;YACfD,MAAM,GAAG,IAAI;UACf;UACAN,KAAK,CAACiB,iBAAiB,CAACR,SAAS,CAAC;UAClCH,MAAM,GAAG,IAAI;UACb,IAAI,CAACC,UAAU,EAAE;YACfA,UAAU,GAAG,KAAK;UACpB;QACF,CAAC,CAAC,EACFb,SAAS,CAACQ,QAAQ,CAAC,CACpB,CAAC,EACFC,YAAY,CAACa,QAAQ,CACtB,CACH,CACF,CAAC;QACDhB,KAAK,CAACkB,iBAAiB,CAACT,SAAS,CAAC;QAClCL,UAAU,CAACe,UAAU,CAACnB,KAAK,CAAC;MAC9B,CACF,CAAC;IACH,CAAC;IACDoB,QAAQ,EAAE,SAAAA,SAAA,EAAM;MACdZ,iBAAiB,IAAIA,iBAAiB,CAAC;QAAEI,QAAQ,EAAEN;MAAO,CAAC,CAAC;MAC5DE,iBAAiB,GAAG,IAAI;MACxBR,KAAK,CAACqB,aAAa,IAAIjB,UAAU,CAACkB,aAAa,CAACtB,KAAK,CAAC;IACxD,CAAC;IACDuB,IAAI,EAAE,SAAAA,KAAA,EAAM;MACV,IAAIjB,MAAM,EAAE;QACVO,OAAO,CAACC,IAAI,CACV,mEACF,CAAC;QACD;MACF;MACA,IAAI,CAACT,SAAS,EAAE;QACdQ,OAAO,CAACC,IAAI,CACV,iEACF,CAAC;QACD;MACF;MACAP,UAAU,GAAG,IAAI;MACjBX,YAAY,CAACJ,GAAG,CAACW,YAAY,CAACS,QAAQ,EAAE,CAAC,CAAC,EAAET,YAAY,CAACS,QAAQ,CAAC;IACpE,CAAC;IACDY,0BAA0B,EAAE,SAAAA,2BAACC,MAAM,EAAK;MACtChB,SAAS,CAACc,IAAI,CAAC,CAAC;MAChBjB,MAAM,GAAGmB,MAAM;MACfzB,KAAK,CAACiB,iBAAiB,CAACR,SAAS,CAAC;IACpC;EACF,CAAC;EACD,OAAOA,SAAS;AAClB;AAMA,eAAe,SAASiB,8BAA8BA,CACpD5B,IAAI,EACJC,sBAAsB,EACtB;EACA,OAAO,UAAC4B,KAAK,EAAEC,KAAK,EAAE3B,MAAM,EAAK;IAC/B,IAAIA,MAAM,KAAK4B,SAAS,EAAE;MACxB,OAAO/B,IAAI,CAAC6B,KAAK,EAAEC,KAAK,EAAE3B,MAAM,CAAC;IACnC;IACA,OAAOJ,wBAAwB,CAACC,IAAI,EAAEC,sBAAsB,EAAE4B,KAAK,EAAEC,KAAK,CAAC;EAC7E,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}