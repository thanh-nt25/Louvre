{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport AnimatedNode, { getCallID, setCallID } from \"./AnimatedNode\";\nimport { adapt } from \"./AnimatedBlock\";\nimport { val } from \"../val\";\nimport invariant from 'invariant';\nvar AnimatedCallFunc = function (_AnimatedNode) {\n  _inherits(AnimatedCallFunc, _AnimatedNode);\n  var _super = _createSuper(AnimatedCallFunc);\n  function AnimatedCallFunc(what, args, params) {\n    var _this;\n    _classCallCheck(this, AnimatedCallFunc);\n    invariant(what instanceof AnimatedNode, \"Reanimated: AnimatedCallFunc 'what' argument should be of type AnimatedNode but got \" + what);\n    invariant(args.every(function (el) {\n      return el instanceof AnimatedNode;\n    }), \"Reanimated: every AnimatedCallFunc 'args' argument should be of type AnimatedNode but got \" + args);\n    invariant(params.every(function (el) {\n      return el instanceof AnimatedNode;\n    }), \"Reanimated: every AnimatedCallFunc 'params' argument should be of type AnimatedNode but got \" + params);\n    _this = _super.call(this, {\n      type: 'callfunc',\n      what: what,\n      args: args,\n      params: params\n    }, _toConsumableArray(args));\n    _this._what = what;\n    _this._args = args;\n    _this._params = params;\n    return _this;\n  }\n  _createClass(AnimatedCallFunc, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"AnimatedCallFunc, id: \" + this.__nodeID;\n    }\n  }, {\n    key: \"beginContext\",\n    value: function beginContext() {\n      var _this2 = this;\n      this._previousCallID = getCallID();\n      setCallID(getCallID() + '/' + this.__nodeID);\n      this._params.forEach(function (param, index) {\n        param.beginContext(_this2._args[index], _this2._previousCallID);\n      });\n    }\n  }, {\n    key: \"endContext\",\n    value: function endContext() {\n      this._params.forEach(function (param) {\n        param.endContext();\n      });\n      setCallID(this._previousCallID);\n    }\n  }, {\n    key: \"__onEvaluate\",\n    value: function __onEvaluate() {\n      this.beginContext();\n      var value = val(this._what);\n      this.endContext();\n      return value;\n    }\n  }]);\n  return AnimatedCallFunc;\n}(AnimatedNode);\nexport function createAnimatedCallFunc(proc, args, params) {\n  return new AnimatedCallFunc(proc, args.map(function (p) {\n    return adapt(p);\n  }), params);\n}","map":{"version":3,"names":["AnimatedNode","getCallID","setCallID","adapt","val","invariant","AnimatedCallFunc","_AnimatedNode","_inherits","_super","_createSuper","what","args","params","_this","_classCallCheck","every","el","call","type","_toConsumableArray","_what","_args","_params","_createClass","key","value","toString","__nodeID","beginContext","_this2","_previousCallID","forEach","param","index","endContext","__onEvaluate","createAnimatedCallFunc","proc","map","p"],"sources":["C:/Users/Admin/Code/git clone/EThrift/client/node_modules/react-native-reanimated/lib/reanimated1/core/AnimatedCallFunc.js"],"sourcesContent":["import AnimatedNode, { getCallID, setCallID } from './AnimatedNode';\r\nimport { adapt } from './AnimatedBlock';\r\nimport { val } from '../val';\r\nimport invariant from 'invariant';\r\n\r\nclass AnimatedCallFunc extends AnimatedNode {\r\n  _previousCallID;\r\n  _what;\r\n  _args;\r\n  _params;\r\n  constructor(what, args, params) {\r\n    invariant(\r\n      what instanceof AnimatedNode,\r\n      `Reanimated: AnimatedCallFunc 'what' argument should be of type AnimatedNode but got ${what}`\r\n    );\r\n    invariant(\r\n      args.every((el) => el instanceof AnimatedNode),\r\n      `Reanimated: every AnimatedCallFunc 'args' argument should be of type AnimatedNode but got ${args}`\r\n    );\r\n    invariant(\r\n      params.every((el) => el instanceof AnimatedNode),\r\n      `Reanimated: every AnimatedCallFunc 'params' argument should be of type AnimatedNode but got ${params}`\r\n    );\r\n    super(\r\n      {\r\n        type: 'callfunc',\r\n        what,\r\n        args,\r\n        params,\r\n      },\r\n      [...args]\r\n    );\r\n    this._what = what;\r\n    this._args = args;\r\n    this._params = params;\r\n  }\r\n\r\n  toString() {\r\n    return `AnimatedCallFunc, id: ${this.__nodeID}`;\r\n  }\r\n\r\n  beginContext() {\r\n    this._previousCallID = getCallID();\r\n    setCallID(getCallID() + '/' + this.__nodeID);\r\n\r\n    this._params.forEach((param, index) => {\r\n      param.beginContext(this._args[index], this._previousCallID);\r\n    });\r\n  }\r\n\r\n  endContext() {\r\n    this._params.forEach((param) => {\r\n      param.endContext();\r\n    });\r\n    setCallID(this._previousCallID);\r\n  }\r\n\r\n  __onEvaluate() {\r\n    this.beginContext();\r\n    const value = val(this._what);\r\n    this.endContext();\r\n    return value;\r\n  }\r\n}\r\n\r\nexport function createAnimatedCallFunc(proc, args, params) {\r\n  return new AnimatedCallFunc(\r\n    proc,\r\n    args.map((p) => adapt(p)),\r\n    params\r\n  );\r\n}\r\n"],"mappings":";;;;;;;;AAAA,OAAOA,YAAY,IAAIC,SAAS,EAAEC,SAAS;AAC3C,SAASC,KAAK;AACd,SAASC,GAAG;AACZ,OAAOC,SAAS,MAAM,WAAW;AAAC,IAE5BC,gBAAgB,aAAAC,aAAA;EAAAC,SAAA,CAAAF,gBAAA,EAAAC,aAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,gBAAA;EAKpB,SAAAA,iBAAYK,IAAI,EAAEC,IAAI,EAAEC,MAAM,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAT,gBAAA;IAC9BD,SAAS,CACPM,IAAI,YAAYX,YAAY,2FAC2DW,IACzF,CAAC;IACDN,SAAS,CACPO,IAAI,CAACI,KAAK,CAAC,UAACC,EAAE;MAAA,OAAKA,EAAE,YAAYjB,YAAY;IAAA,EAAC,iGAC+CY,IAC/F,CAAC;IACDP,SAAS,CACPQ,MAAM,CAACG,KAAK,CAAC,UAACC,EAAE;MAAA,OAAKA,EAAE,YAAYjB,YAAY;IAAA,EAAC,mGAC+Ca,MACjG,CAAC;IACDC,KAAA,GAAAL,MAAA,CAAAS,IAAA,OACE;MACEC,IAAI,EAAE,UAAU;MAChBR,IAAI,EAAJA,IAAI;MACJC,IAAI,EAAJA,IAAI;MACJC,MAAM,EAANA;IACF,CAAC,EAAAO,kBAAA,CACGR,IAAI;IAEVE,KAAA,CAAKO,KAAK,GAAGV,IAAI;IACjBG,KAAA,CAAKQ,KAAK,GAAGV,IAAI;IACjBE,KAAA,CAAKS,OAAO,GAAGV,MAAM;IAAC,OAAAC,KAAA;EACxB;EAACU,YAAA,CAAAlB,gBAAA;IAAAmB,GAAA;IAAAC,KAAA,EAED,SAAAC,SAAA,EAAW;MACT,kCAAgC,IAAI,CAACC,QAAQ;IAC/C;EAAC;IAAAH,GAAA;IAAAC,KAAA,EAED,SAAAG,aAAA,EAAe;MAAA,IAAAC,MAAA;MACb,IAAI,CAACC,eAAe,GAAG9B,SAAS,CAAC,CAAC;MAClCC,SAAS,CAACD,SAAS,CAAC,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC2B,QAAQ,CAAC;MAE5C,IAAI,CAACL,OAAO,CAACS,OAAO,CAAC,UAACC,KAAK,EAAEC,KAAK,EAAK;QACrCD,KAAK,CAACJ,YAAY,CAACC,MAAI,CAACR,KAAK,CAACY,KAAK,CAAC,EAAEJ,MAAI,CAACC,eAAe,CAAC;MAC7D,CAAC,CAAC;IACJ;EAAC;IAAAN,GAAA;IAAAC,KAAA,EAED,SAAAS,WAAA,EAAa;MACX,IAAI,CAACZ,OAAO,CAACS,OAAO,CAAC,UAACC,KAAK,EAAK;QAC9BA,KAAK,CAACE,UAAU,CAAC,CAAC;MACpB,CAAC,CAAC;MACFjC,SAAS,CAAC,IAAI,CAAC6B,eAAe,CAAC;IACjC;EAAC;IAAAN,GAAA;IAAAC,KAAA,EAED,SAAAU,aAAA,EAAe;MACb,IAAI,CAACP,YAAY,CAAC,CAAC;MACnB,IAAMH,KAAK,GAAGtB,GAAG,CAAC,IAAI,CAACiB,KAAK,CAAC;MAC7B,IAAI,CAACc,UAAU,CAAC,CAAC;MACjB,OAAOT,KAAK;IACd;EAAC;EAAA,OAAApB,gBAAA;AAAA,EAzD4BN,YAAY;AA4D3C,OAAO,SAASqC,sBAAsBA,CAACC,IAAI,EAAE1B,IAAI,EAAEC,MAAM,EAAE;EACzD,OAAO,IAAIP,gBAAgB,CACzBgC,IAAI,EACJ1B,IAAI,CAAC2B,GAAG,CAAC,UAACC,CAAC;IAAA,OAAKrC,KAAK,CAACqC,CAAC,CAAC;EAAA,EAAC,EACzB3B,MACF,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}